#Този Makefile е пример как може да се компилират няколко файла 
#в един в конкретния случай примера се състои от два файла val.c
#и prg.c
#val.c съдържа валидираща функция, която се ползва в prg.c, зa целта
#не е необходимо да се използва директивата include, тъй като кода на val.c ще се 
#прибави към кода на prg.c, достатъчно е само да се декларира прототипа на функцията в 
#prg.c двата сорс кода се компилират до обектни файлове и после обектните файлове се 
#компилират в един бинарен. Тази техника пести време за компилация, особено при големи 
#проекти, където времето за компилация е доста голямо.
#От друга страна ползваме cos.c и val.c за генерирането на програма cos

#!!!!Makefile прави така, че се компилират само файловете, които са изменяни!!!!
#

#https://www.youtube.com/watch?v=GExnnTaBELk&t=1806s линк от който е взет примера естествено леко опростен :)


#Общ синтаксис на "рецептите":
#Цел: зависимост
#<tab>команда

all: cos prg #Изпълнениети започва от първия ред в тази рецепта се посочва кои рецепти да се изпълнят
#рецепта cos се изпълнява на ред 30 а prg  на ред 21

prg: prg.o val.o #Ако файловете prg.o и val.o не са генерирани се изпълняват редове 28 и 31
	gcc prg.o val.o -o prg

prg.o: prg.c val.h
	gcc prg.c -c 

val.o: val.c
	gcc val.c -c 

cos: cos.o val.o #Ако файловете cos.o и val.o не са генерирани се изпълняват редове 37 и 31
	gcc val.o cos.o -o cos -l m

cos.o: cos.c val.h
	gcc cos.c -c -l m


#Тук добавяме изчистващи рецепти
	
clean: 
	@rm *.o prg cos
	@echo "Clean all generated files"

clear: 
	@rm *.o prg cos
	@echo "Clean all generated files"


#Схема на компилиране със числото пред файла е обозначен теда на който се изпълнява командата
#В дъното на схемата се разполагат изходните файлове, ако някой файл по веригата липсва Makefile се
#обръща към съответната рецепта, също и когато се изменя някой от изходните файлове

#      25.prg       34.cos
#     /       \     /     \
# 28.prg.o    31.val.o   37.cos.o
#    |           |          |
# prg.c val.h   val.c    cos.c val.h
# 